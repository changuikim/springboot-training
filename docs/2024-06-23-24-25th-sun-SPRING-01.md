# 8 책 댓글 기능 구현하기

## 8.1 댓글 Entity 생성하기

> `package com.spring.onedayboot.book.entity;` 패키지에 `Comment` 엔티티를 생성합니다.

```java
package com.spring.onedayboot.book.entity;

import com.spring.onedayboot.common.entity.BaseEntity;
import jakarta.persistence.*;
import lombok.*;
import lombok.experimental.SuperBuilder;

@Entity
@Table(name = "comment")
@Getter
@SuperBuilder(toBuilder = true)
@AllArgsConstructor
@NoArgsConstructor
@EqualsAndHashCode(onlyExplicitlyIncluded = true)
@ToString(callSuper = true, onlyExplicitlyIncluded = true)
public class Comment extends BaseEntity {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    @Column(name = "comment_id", columnDefinition = "BIGINT")
    @EqualsAndHashCode.Include
    @ToString.Include
    private Long commentId;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "book_id", columnDefinition = "BIGINT")
    private Book book;

    @Column(name = "comment", columnDefinition = "VARCHAR(255)", nullable = false)
    @ToString.Include
    private String comment;

    @Column(name = "page", columnDefinition = "INT", nullable = false)
    @ToString.Include
    private Integer page;
}
```

### 8.1.1 클래스 어노테이션

- `Comment` 엔티티는 `BaseEntity` 클래스를 상속받습니다.

  - `BaseEntity` 클래스는 `JPA Auditing`을 사용하여 각 엔티티의 생성일, 수정일을 관리할 수 있도록 구현되어 있습니다.

- `@Entity` : 이 클래스는 JPA 엔티티이며, 각 인스턴스는 데이터베이스 테이블의 각 행과 매핑됩니다.

  - JPA 엔티티는 기본 생성자가 있어야 합니다. (`@NoArgsConstructor`)

- `@Table(name = ?)` : 엔티티가 매핑되는 데이터베이스의 테이블 이름을 명시합니다.

- [`@Getter`](https://projectlombok.org/features/Getter) : 엔티티의 모든 필드에 대한 `getter` 메서드를 생성합니다.

- [`@SuperBuilder`](https://projectlombok.org/features/experimental/SuperBuilder) : 엔티티의 인스턴스를 빌더 패턴으로 생성할 수 있도록 하는 구현체로, 부모에게 상속받은 필드에 대해서도 빌더를 사용할 수 있습니다.

  - 모든 필드를 매개변수로 받는 생성자가 있어야 합니다. (`@AllArgsConstructor`)
  - `toBuilder = true` : 기존 인스턴스를 복사하여 새로운 인스턴스를 생성하는 `toBuilder()` 메서드를 사용할 수 있도록 합니다.

- [`@AllArgsConstructor`](https://projectlombok.org/features/constructor) : 모든 필드를 매개변수로 받는 생성자를 생성합니다.

- [`@NoArgsConstructor`](https://projectlombok.org/features/constructor) : 매개변수가 없는 기본 생성자를 생성합니다.

- [`@EqualsAndHashCode`](https://projectlombok.org/features/EqualsAndHashCode) : `equals`와 `hashCode` 메서드를 생성합니다.

  - `equals` : 두 객체가 같은지 비교합니다.
  - `hashCode` : 두 객체가 같은지 비교할 때 사용하는 해시코드를 생성합니다.
  - `onlyExplicitlyIncluded = true` : `@EqualsAndHashCode.Include` 어노테이션이 명시된 필드만 포함하여 `equals`와 `hashCode` 메서드를 생성합니다.
  - 이 엔티티에서는 기본키만을 사용하여 엔티티의 인스턴스 간 동등성을 비교합니다.

- [`@ToString`](https://projectlombok.org/features/ToString) : 엔티티 인스턴스를 문자열로 표현하는 `toString` 메서드를 생성합니다.

  - `callSuper = true` : 부모 클래스의 필드도 포함하여 `toString` 메서드를 생성합니다.
  - `onlyExplicitlyIncluded = true` : `@ToString.Include` 어노테이션이 명시된 필드만 포함하여 `toString` 메서드를 생성합니다.
  - 이 엔티티에서는 기본키, 댓글 내용, 페이지 정보만을 사용하여 엔티티의 문자열 표현을 생성합니다.
  - `toString` 메서드의 대상에 참조 필드가 포함되어 있으면 순환 참조가 발생할 수 있습니다. 따라서 문자열에 표시할 필드를 명시적으로 지정합니다.

### 8.1.2 필드 어노테이션

- `Comment` 엔티티는 댓글 식별자, 책 엔티티에 대한 참조, 댓글 내용, 페이지 정보를 담고 있습니다.

- `commentId` 필드는 엔티티의 인스턴스를 식별하는 기본키입니다.

  - `@Id` : 해당 필드가 엔티티의 기본키임을 나타냅니다. 엔티티는 반드시 기본키를 가져야 합니다.
  - `@GeneratedValue` : 해당 필드가 데이터베이스에서 자동으로 생성되는 값임을 나타냅니다.
    - `strategy` : 기본키 생성 전략을 설정합니다.
      - `IDENTITY` : 데이터베이스에서 기본키를 생성합니다. ex) MySQL의 AUTO_INCREMENT
      - `SEQUENCE` : 데이터베이스 시퀀스를 사용하여 기본키를 생성합니다. ex) Oracle의 SEQUENCE
      - `TABLE` : 데이터베이스 테이블을 사용하여 기본키를 생성합니다.
      - `AUTO` : 데이터베이스에 따라 기본키 생성 전략을 선택합니다.
  - `@Column` : 데이터베이스 컬럼을 설정합니다.
    - `name` : 데이터베이스 컬럼의 이름을 설정합니다.
    - `columnDefinition` : dialect에 따라 데이터베이스에 맞는 컬럼 타입을 설정할 수 있습니다.
    - `nullable` : 데이터베이스 컬럼이 NULL 값을 허용하는지 설정합니다.

- `book` 필드는 댓글이 달린 책 엔티티의 인스턴스에 대한 참조입니다.

  - 하나의 책에는 여러 개의 댓글이 달릴 수 있습니다.
  - 책의 입장에서 댓글은 일대다(1:N) 관계이며, 댓글이 자식 테이블입니다.
  - 댓글의 입장에서 책은 다대일(N:1) 관계이며, 책이 부모 테이블입니다.
  - 댓글 테이블은 책 테이블의 기본키(PK)를 참조하는 외래키(FK)를 컬럼으로 가지고 있습니다. 관계를 생성하는 쪽인 댓글 테이블을 관계의 주인 Owner라고 부르기도 합니다.
  - 댓글 엔티티의 인스턴스는 단 하나의 책 엔티티의 인스턴스를 참조합니다. 따라서 댓글 엔티티가 책 엔티티를 참조하는 필드를 가집니다.
  - 다대일 관계를 `JPA`에서는 `@ManyToOne` 어노테이션을 사용하여 표현합니다. 이를 단방향 매핑이라고 합니다.
  - `@ManyToOne` : 다대일(N:1) 관계를 나타냅니다.
    - `fetch` : 연관 엔티티를 조회할 때 함께 조회할 방법을 설정합니다.
      - `LAZY` : 연관 엔티티를 지연 로딩합니다. 연관 엔티티를 조회하지 않고, 실제로 사용할 때 조회합니다. -> N + 1 문제가 발생할 수 있습니다.
      - `EAGER` : 연관 엔티티를 즉시 로딩합니다. 연관 엔티티를 함께 조회합니다. -> 성능 저하가 발생할 수 있습니다.
  - `JoinColumn` : 데이터베이스에서 조인의 기준이 되는 외래키를 명시합니다.
    - `name` : 외래키의 이름을 설정합니다.
    - `columnDefinition` : dialect에 따라 데이터베이스에 맞는 컬럼 타입을 설정할 수 있습니다.
  - 책 엔티티의 인스턴스는 여러 개의 댓글 엔티티의 인스턴스를 참조할 수 있습니다. 따라서 책 엔티티는 댓글 엔티티의 컬렉션을 가질 수 있습니다.
  - 일대다 관계를 `JPA`에서는 `@OneToMany` 어노테이션을 사용하여 표현합니다. 책 엔티티 쪽에서도 댓글 엔티티를 참조할 경우, 이를 양방향 매핑이라고 합니다.

- `comment` 필드는 댓글 내용을 담고 있습니다.

- `page` 필드는 책에서 댓글이 달린 페이지에 대한 정보를 담고 있습니다.

## 8.2 Hibernate 결과 확인하기

> Spring Boot 애플리케이션을 실행하고, `http://localhost:8080/h2-console`로 접속하여 `comment` 테이블의 데이터를 조회합니다.

```sql
Hibernate:
    create table comment (
        page INT not null,
        book_id BIGINT,
        comment_id BIGINT generated by default as identity,
        created_at timestamp(6),
        modified_at timestamp(6),
        comment VARCHAR(255) not null,
        primary key (comment_id)
    )
Hibernate:
    alter table if exists comment
       add constraint FKkko96rdq8d82wm91vh2jsfak7
       foreign key (book_id)
       references book
```

- `comment` 테이블이 생성되었습니다.
- PAGE, BOOK_ID, COMMENT_ID, CREATED_AT, MODIFIED_AT, COMMENT 컬럼이 생성되었습니다.

## 8.3 댓글 Repository 생성하기

> `package com.spring.onedayboot.book.repository;` 패키지에 `CommentRepository` 인터페이스를 생성합니다.

```java
package com.spring.onedayboot.book.repository;

import com.spring.onedayboot.book.entity.Comment;
import org.springframework.data.jpa.repository.JpaRepository;

public interface CommentRepository extends JpaRepository<Comment, Integer> {
}
```

- `CommentRepository` 인터페이스는 PK 타입이 Long인 `Comment` 엔티티를 관리하는 `JpaRepository` 인터페이스를 상속받습니다.

## 8.4 Request DTO 생성하기

> `package com.spring.onedayboot.book.dto;` 패키지에 `CommentCreateRequest` 클래스를 생성합니다.

```java
package com.spring.onedayboot.book.dto;

import jakarta.validation.constraints.Positive;
import lombok.Getter;
import lombok.NonNull;
import lombok.Setter;

@Getter
@Setter
public class CommentCreateRequest {
    @NonNull
    @Positive
    private Long bookId;

    @NonNull
    private String comment;

    private Integer page;
}
```

- `CommentCreateRequest` 클래스는 댓글 생성 요청을 처리하는 DTO 클래스입니다.
- `bookId` 필드는 댓글이 달릴 책의 식별자를 담고 있습니다.
- `comment` 필드는 댓글 내용을 담고 있습니다.
- `page` 필드는 댓글이 달린 페이지 정보를 담고 있습니다.

## 8.5 Response DTO 생성하기

> `package com.spring.onedayboot.book.dto;` 패키지에 `CommentCreateResponse` 클래스를 생성합니다.

```java
package com.spring.onedayboot.book.dto;

import com.spring.onedayboot.book.entity.Comment;
import lombok.Builder;
import lombok.Getter;

@Builder
@Getter
public class CommentReadResponse {

    private Long commentId;
    private Long bookId;
    private String comment;
    private Integer page;

    /**
     * Comment 객체를 CommentReadResponse 객체로 변환한다.
     * @param comment 변환할 Comment 객체
     * @return 변환된 CommentReadResponse 객체
     * @throws IllegalArgumentException Comment 객체가 null 일 때
     */
    public static CommentReadResponse fromComment(Comment comment) {
        if (comment == null) {
            throw new IllegalArgumentException("Comment 객체는 null 일 수 없습니다.");
        }

        return CommentReadResponse.builder()
                .commentId(comment.getCommentId())
                .bookId(comment.getBook().getBookId())
                .comment(comment.getComment())
                .page(comment.getPage())
                .build();
    }
}
```

- `CommentReadResponse` 클래스는 댓글 조회 응답을 처리하는 DTO 클래스입니다.
- `commentId` 필드는 댓글 식별자를 담고 있습니다.
- `bookId` 필드는 댓글이 달린 책의 식별자를 담고 있습니다.
- `comment` 필드는 댓글 내용을 담고 있습니다.
- `page` 필드는 댓글이 달린 페이지 정보를 담고 있습니다.
- `fromComment` 메서드는 `Comment` 엔티티를 `CommentReadResponse` DTO로 변환하는 정적 팩토리 패턴을 구현하는 메서드입니다.

## 8.6 댓글 Service 생성하기

> `package com.spring.onedayboot.book.service;` 패키지에 `CommentService` 인터페이스를 생성합니다.

```java
package com.spring.onedayboot.book.service;

import com.spring.onedayboot.book.dto.CommentCreateRequest;
import com.spring.onedayboot.book.dto.CommentReadResponse;
import com.spring.onedayboot.book.entity.Book;
import com.spring.onedayboot.book.entity.Comment;
import com.spring.onedayboot.book.repository.BookRepository;
import com.spring.onedayboot.book.repository.CommentRepository;
import lombok.RequiredArgsConstructor;
import org.springframework.stereotype.Service;

@Service
@RequiredArgsConstructor
public class CommentServiceImpl implements CommentService {

    private final BookRepository bookRepository;
    private final CommentRepository commentRepository;

    /**
     * 코멘트를 등록한다.
     * @param request 코멘트 등록 정보를 담은 DTO
     * @return 등록된 코멘트의 id
     */
    @Override
    public CommentReadResponse createComment(CommentCreateRequest request) {
        Book book = this.bookRepository.findById(request.getBookId())
                .orElseThrow(() -> new IllegalArgumentException("책 정보를 찾을 수 없습니다."));
        Comment comment = request.toEntity(book);
        comment = this.commentRepository.save(comment);
        return CommentReadResponse.fromComment(comment);
    }
}
```

- `createComment` 메서드는 댓글을 등록하는 메서드입니다.
- `findById` 메서드를 사용해 요청 객체에 담긴 책 식별자로 책 엔티티의 인스턴스를 조회합니다.
- `toEntity` 메서드를 사용해 요청 객체를 댓글 엔티티로 변환합니다.
  - 모든 엔티티는 참조를 통해 그래프 탐색 방식으로 연관된 엔티티를 조회할 수 있습니다.
- `save` 메서드를 사용해 댓글 엔티티를 저장하고, 저장된 댓글 엔티티를 반환합니다.
- 반환된 댓글 엔티티를 `CommentReadResponse` DTO로 변환하여 호출된 위치로 반환합니다.

## 8.7 댓글 Controller 생성하기

> `package com.spring.onedayboot.book.controller;` 패키지에 `CommentController` 클래스를 생성합니다.

```java
package com.spring.onedayboot.book.controller;

import com.spring.onedayboot.book.dto.CommentCreateRequest;
import com.spring.onedayboot.book.dto.CommentReadResponse;
import com.spring.onedayboot.book.service.CommentService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestMethod;
import org.springframework.web.bind.annotation.RestController;

@RestController
@RequestMapping("/comment")
public class CommentController {

    private final CommentService commentService;

    @Autowired
    public CommentController(CommentService commentService) {
        this.commentService = commentService;
    }

    @RequestMapping(method = RequestMethod.POST, value = "/create")
    public ResponseEntity<CommentReadResponse> create(@RequestBody CommentCreateRequest request) {
        CommentReadResponse response = this.commentService.createComment(request);
        return ResponseEntity.status(HttpStatus.CREATED).body(response);
    }

}
```

### 8.7.1 클래스 어노테이션

- `CommentController` 클래스는 댓글 관련 요청을 처리하는 컨트롤러 클래스입니다.
- `@RestController` : `@Controller`와 `@ResponseBody`를 합친 어노테이션으로, 해당 클래스의 모든 메서드의 반환값을 HTTP 응답 본문으로 사용합니다.
  - `@Controller` : 해당 클래스를 컨트롤러 빈으로 스프링 컨테이너에 등록합니다.
  - `@ResponseBody` : 자바 객체를 JSON 형식으로 변환하는 직렬화를 수행합니다. 기본적으로 jackson 라이브러리의 `ObjectMapper`를 사용합니다.

### 8.7.2 메서드

- `create` 메서드는 댓글을 등록하는 요청을 처리하고, 댓글을 등록한 후 응답을 반환하는 메서드입니다.
- `ResponseEntity` : HTTP 응답을 나타내는 클래스로, HTTP 상태 코드, 헤더, 본문을 포함합니다.
  - `status` 메서드 : HTTP 상태 코드를 설정합니다.
  - `headers` 메서드 : HTTP 응답 헤더를 설정합니다.
  - `body` 메서드 : HTTP 응답 본문에 담을 객체를 설정합니다.
- `@RequestBody` : HTTP 요청 본문에 담긴 JSON 데이터를 자바 객체로 변환하는 역직렬화를 수행합니다.

## 8.8 Postman으로 댓글 등록 API 테스트하기

> Postman을 사용하여 댓글 등록 API를 테스트합니다.

```sql
Hibernate:
    select
        b1_0.book_id,
        b1_0.created_at,
        b1_0.modified_at,
        b1_0.price,
        b1_0.title
    from
        book b1_0
    where
        b1_0.book_id=?
Hibernate:
    insert
    into
        comment
        (book_id, comment, created_at, page, comment_id)
    values
        (?, ?, ?, ?, default)
```

- 댓글 등록 API를 테스트한 결과, 요청에 대한 응답이 성공적으로 반환되었습니다.
- 첫번째 Hibernate:
  - FROM : `book` 테이블을 조회합니다.
  - WHERE : `book_id`가 `1`인 책을 조회합니다.
  - SELECT : `book_id`, `created_at`, `modified_at`, `price`, `title` 컬럼을 조회합니다.
- 두번째 Hibernate:
  - INSERT INTO : `comment` 테이블의 `book_id`, `comment`, `created_at`, `page`, `comment_id` 컬럼에 값을 삽입합니다.
  - VALUES : 각 컬럼에 삽입할 값을 설정합니다.

## 8.9 책 엔티티에 댓글 컬렉션 추가하기

> `package com.spring.onedayboot.book.entity;` 패키지에 `Book` 엔티티를 수정합니다.

```java
package com.spring.onedayboot.book.entity;

import com.spring.onedayboot.common.entity.BaseEntity;
import jakarta.persistence.*;
import lombok.*;
import lombok.experimental.SuperBuilder;

import java.util.ArrayList;
import java.util.List;

@Entity
@Table(name = "book")
@Getter
@SuperBuilder(toBuilder = true)
@AllArgsConstructor
@NoArgsConstructor
@EqualsAndHashCode(callSuper = true, onlyExplicitlyIncluded = true)
@ToString(callSuper = true, onlyExplicitlyIncluded = true)
public class Book extends BaseEntity {

    // ... 생략

    @OneToMany(mappedBy = "book", fetch = FetchType.LAZY)
    private List<Comment> commentList = new ArrayList<>();

    // ... 생략
}
```

- 부모 엔티티인 `Book` 에서도 자식 엔티티인 `Comment` 를 참조할 수 있도록 컬렉션 필드를 추가합니다.
- 일대다 (1:N) 관계는 `@OneToMany` 어노테이션을 사용하여 표현합니다.
- `mappedBy` 속성으로 관계의 주인으로 상대 엔티티의 `book` 필드를 지정합니다.
- `Comment` 엔티티를 List 컬렉션으로 관리합니다.

## 8.10 Response DTO 만들기

> `package com.spring.onedayboot.book.dto;` 패키지에 `CommentListResponse` 클래스를 생성합니다.

```java
package com.spring.onedayboot.book.dto;

import com.spring.onedayboot.book.entity.Comment;
import lombok.Builder;
import lombok.Getter;

import java.time.LocalDateTime;

@Builder
@Getter
public class CommentListResponse {
    private Long commentId;
    private String comment;
    private Integer page;
    private LocalDateTime createdAt;
    private String displayComment;

    /**
     * Comment 객체를 CommentListResponse 객체로 변환한다.
     * @param comment 변환할 Comment 객체
     * @return 변환된 CommentListResponse 객체
     */
    public static CommentListResponse fromComment(Comment comment) {
        return CommentListResponse.builder()
                .commentId(comment.getCommentId())
                .comment(comment.getComment())
                .page(comment.getPage())
                .createdAt(comment.getCreatedAt())
                .displayComment(comment.getComment().length() > 10 ? comment.getComment().substring(0, 10) + "..." : comment.getComment()
                )
                .build();
    }
}
```

- `CommentListResponse` 클래스는 댓글 조회 응답을 처리하는 DTO 클래스입니다.
- `commentId` 필드는 댓글 식별자를 담고 있습니다.
- `comment` 필드는 댓글 내용을 담고 있습니다.
- `page` 필드는 댓글이 달린 페이지 정보를 담고 있습니다.
- `createdAt` 필드는 댓글 생성일을 담고 있습니다.
- `displayComment` 필드는 댓글 내용을 10자까지만 표시하고, 10자 이상일 경우 `...`으로 표시하는 가상의 컬럼을 나타내는 필드입니다.

## 8.11 책 상세조회 Response DTO 수정하기

> `package com.spring.onedayboot.book.dto;` 패키지에 `BookReadResponse` 클래스를 수정합니다.

```java
package com.spring.onedayboot.book.dto;

import com.spring.onedayboot.book.entity.Book;
import lombok.Builder;
import lombok.Getter;

import java.time.LocalDateTime;
import java.util.List;

@Builder
@Getter
public class BookReadResponse {
    private Long bookId;
    private String title;
    private Long price;
    private LocalDateTime createdAt;
    private List<CommentListResponse> commentList;

    /**
     * Book 객체를 BookReadResponse 객체로 변환한다.
     * @param book 변환할 Book 객체
     * @return 변환된 BookReadResponse 객체
     */
    public static BookReadResponse fromBook(Book book) {
        return BookReadResponse.builder()
                .bookId(book.getBookId())
                .title(book.getTitle())
                .price(book.getPrice())
                .createdAt(book.getCreatedAt())
                .commentList(book.getCommentList().stream().map(comment -> CommentListResponse.fromComment(comment)).toList())
                .build();
    }
}
```

- `BookReadResponse` 클래스는 책 상세 조회 응답을 처리하는 DTO 클래스입니다.
- `commentList` 필드는 책에 달린 댓글 목록을 담고 있습니다.
- `fromBook` 메서드에 `stream`을 사용하여 댓글 목록을 `CommentListResponse` DTO로 변환하여 컬렉션으로 설정하는 로직을 추가합니다.

## 8.12 책 댓글 기능 확인하기

> 댓글을 추가 후 `localhost:8080/book/1`로 접속하여 책 상세 조회 API를 테스트합니다.

```sql
Hibernate:
    select
        b1_0.book_id,
        b1_0.created_at,
        b1_0.modified_at,
        b1_0.price,
        b1_0.title
    from
        book b1_0
    where
        b1_0.book_id=?
Hibernate:
    select
        cl1_0.book_id,
        cl1_0.comment_id,
        cl1_0.comment,
        cl1_0.created_at,
        cl1_0.modified_at,
        cl1_0.page
    from
        comment cl1_0
    where
        cl1_0.book_id=?
```

- 댓글이 추가된 책 상세 조회 API를 테스트한 결과, 요청에 대한 응답이 성공적으로 반환되었습니다.
- 첫번째 Hibernate:
  - FROM : `book` 테이블을 조회합니다.
  - WHERE : `book_id`가 `1`인 책을 조회합니다.
  - SELECT : `book_id`, `created_at`, `modified_at`, `price`, `title` 컬럼을 조회합니다.
- 두번째 Hibernate:
  - FROM : `comment` 테이블을 조회합니다.
  - WHERE : `book_id`가 `1`인 댓글을 조회합니다.
  - SELECT : `book_id`, `comment_id`, `comment`, `created_at`, `modified_at`, `page` 컬럼을 조회합니다.
